Вопрос:

Что такое конкурентность (concurrency)?

Ответ:

Возможность одновременного выполнения нескольких потоков и процессов.

==========


Вопрос:

Что такое планировщик потоков (thread scheduler)?


Ответ:

Это механизм операционной системы, управляющий выполнением потоков. Центральный процессор не может одновременно выполнять несколько операций, поэтому планировщик потоков выделяет процессорное время каждому потоку по какому-либо принципу. Например, round-robin schedule, когда каждый поток получает равные порции времения для выполнения (например, 100 мс) по круговой схеме.

===


Вопрос:

Что такое переключение контекста (context switch)?

ответ:

Это процесс сохранения состояния потока в момент передачи процессору следующего потока, состояние которого восстанавливается из ранее сохраненного. Переключение контекста может являться источников снижения быстродействия, т.к. сохранение/восстановление состояния потоков может занимать время.


===


Вопрос:

Что такое приоритет потока (thread priority) и как он выглядит в Java?

Ответ:

Это числовое значение, которое используется планировщиком потоков для определения того, какой поток важнее. Если появляется поток с более высоким приоритетом, чем все остальные, выполнение сразу передается ему. 
В Java приоритет потока выражается целым числом. У класса java.lang.Thread есть константы Thread.MIN_PRIORITY, Thread.NORM_PRIORITY, Thread.MAX_PRIORITY, равные 1, 5, 10 соответственно. По умолчанию приоритет пользовательского потока равен 5.

===

Вопрос:

Опишите интерфейс Runnable

Ответ:

package java.lang;
@FunctionalInterface public interface Runnable {
    void run();
}

Интерфейс выражает действия, которые будут выполнены отдельным потоком.


===


Вопрос: 

Отметьте лямбда-выражения, валидные для интерфейса Runnable

Ответ:

valid:
() -> System.out.println("Hello World")
() -> {int i=10; i++;}
() -> {return;}
() -> {}
invalid: (т.к. возвращают значение)
() -> ""
() -> 5
() -> {return new Object();}


===

Вопрос:

Для создания задач, выполняемых отдельным потоком, до сих пор актуально создавать класс, имплементирующий интерфейс Runnable:

public class CalculateAverages implements Runnable {
    private double[] scores;
    public CalculateAverages(double[] scores) {
        this.scores = scores;
    }
    public void run() {
        // Define work here that uses the scores object
    }
}


===


Вопрос:

Опишите 2 способа создать задачу, выполняемую в потоке.

Ответ:

Общий подход - получить экземпляр класса Thread и вызвать на нем метод start(). Получить экземпляр можно как раз 2-мя способами:

1. Передать экземпляр Runnable или соответствующую лямбду в конструктор класса Thread:

public class PrintData implements Runnable {
    public void run() {
        for(int i=0; i<3; i++)
            System.out.println("Printing record: "+i);
    }
	public static void main(String[] args) {
        new Thread(new PrintData()).start();
    }
}

2. Менее популярный. Создать класс, наследующий классу Thread, и переопределить в нем метод run() (используется при создании собственных приоритизированных потоков - наследников Thread):

public class ReadInventoryThread extends Thread {
    public void run() {
        System.out.println("Printing zoo inventory");
    }
    public static void main(String[] args) {
        new ReadInventoryThread().start();
    }
}

===

Вопрос:

Если мы запускаем несколько отдельных равнозначных потоков, то предсказать порядок их выполнения невозможно. Но в каждом отдельном потоке инструкции выполняются четко по порядку.

===

Вопрос, в т.ч. в "особенности экзамена":

На экзамене надо быть внимательным: запуск метода run() не запускает отдельный поток, только запуск Thread.start()

===

Вопрос:

Опишите преимущества того или иного способа запуска задачи в отдельном потоке.

Ответ:

1. Наследование от Thread:
	- можно создать собственноый класс-поток с особым поведением, на который будут опираться многие задачи (приоритизированные потоки)
2. Имплементация Runnable:
	- любой класс можно сделать Runnable.
	- объект задача отделен от объекта потока - лучший ООП-дизайн.
	- для объектов Runnable существует обширное Concurrency API
	
	
p.334 Polling with sleep

